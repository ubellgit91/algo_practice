# Day 1 알고리즘.

## 알고리즘이란

알고리즘은 어떤 문제를 풀기 위한 **절차**나 **방법**이다. 

어떤 문제가 있을 때 주어진 '입력'정보를 원하는 출력(답) 정보로 만드는 일련의 과정을 **구체적**이고 **명료하게** 적은 것.

## 알고리즘 분석

문제를 푸는 방법은 꼭 한가지만 있는 것이 아니다. 한가지 문제를 풀 때에도 여러가지 해법이 이씩 마련인데, 이 중에서도 상황에 맞는 적당한 알고리즘을 골라 쓰려면 어떤 알고리즘이 어떤 특징을 지니고 있는지 , 얼마나 계산기 빠르고 편한지 등을 알아야 한다.

이처럼 알고리즘의 성능이나 특징을 분석하는 것을 '알고리즘 분석' 이라고 한다.

알고리즘 분석에는 수학적 지식이 필요하다.

## 알고리즘 성능에 영향을 미치는 것

알고리즘에는 입력이 필요한데 입력 크기가 알고리즘 수행 성능에 영향을 미칠 때가 많다. 

입력 크기가 커지면 알고리즘의 계산도 복잡해지기 때문이다.

입력크기가 커지면 계산 횟수가 커지고 이로 인해 계산의 과정이 늘어나 복잡하게 된다.

## 1부터 ~ n까지의 합 구하기

1부터 n까지의 연속한 숫자의 합을 구하는 문제를 풀기위한 알고리즘을 최대한 구체적으로 적어보자.

1. 합을 기록할 변수 s를 만들고 0을 저장한다.(변수명은 자유)
2. 변수 i를 만들어 1부터~n까지 숫자를 1씩 증가시키며 반복함
3. [반복 블록] 기존의 s에 i를 더하여 얻은 값을 다시 s에 저장합니다.
4. 반복이 끝났을 때 s에 저장된 값이 결과값이 된다.

```python
# algo test1
# 1~n까지의 합을 구하는 알고리즘.
#
# 1. n을 입력받는다.
# 2. 1~n까지의 값을 for each를 통해 하나씩 가져온다.
# 3. 현재 값 result에 += (더하기 대입) 한다.
# 4. result를 return한다.
class MyAlgo():
    def __init__(self):
        self.result = 0

    def cal(self, n):
        for i in range(1, n+1):
            self.result += i
        return self.result


# 교재에서 제시한 방법
def sum_n(n):
    s = 0
    for i in range(1, n+1):
        s = s+i
    return s
# 방법 2 더 간단하고 편한 방법.
def sum_n2(n):
    return n * (n + 1) // 2 # //는 정수 나눗셈.


if __name__=="__main__":
    n = int(input("범위 n 값을 입력 : "))
    my = MyAlgo()
    result = my.cal(n)
    print(result)
    result = sum_n(n)
    print(result)
    result = sum_n2(n)
    print(result)


```

두번째 방법이 계산복잡도가 낮아 성능상 더 효과적인 알고리즘이다.

1. 첫번째 알고리즘은 덧셈을 결국 n번 반복해야 한다.
2. 두번째 알고리즘은 어떤 수가 들어오던 괄호 안의 값을 더하고, 괄호 밖 수와 곱하고, 그걸 2로 나누는 딱 3단계 과정만을 거친다.



## 빅오 (Big O) 표기법

**알고리즘 계산이 얼마나 복잡한지 나타낸 정도**를 "계산 복잡도(시간복잡도)"라고 한다. 

> 계산 복잡도를 표현하는 방법에는 여러가지가 있는데 그 중 대문자 O 표기법을 가장 많이 사용한다.

이는 알고리즘에서 필요한 계산 회수를 정확한 숫자로 표현하는 것이 아니라 

입력크기와 계산 회수의 관계에 따라 표현한다.

계산횟수가 입력크기 n과 정비례하면 모두 O(n)으로 표기힌다.

즉 1번은 **입력크기 n에따라 계산횟수가 계속 늘어나는 정비례 관계**이므로 **O(n)**이다.

두번 째 해답 알고리즘은 입력크기 n이 몇이던 사칙연산을 딱 세번만 수행한다. 즉 n이 몇이든 **계산 횟수는 일정하다**는 뜻이다. 이 때 계산복잡도는 **O(1)** 로 표현한다. n이 몇이 들어오든 계산횟수는 변함이 없기 때문이다.



### 연습문제

#### 1-1. 1부터 n까지 연속한 숫자의 제곱의 합을 구하는 프로그램을 for 반복문으로 만들어라.

```python
class Prac():
    def __init__(self):
        self.result = 0
    # for문을 이용해 입력받은 숫자의 제곱의 합을 구하라.
    def Jegop(self, n):
        for i in range(1, n+1):
            self.result += i ** 2
        return self.result


if __name__=="__main__":
    n = int(input("범위 n 값을 입력 : "))
    my = Prac()
    print(my.Jegop(n))

```

1. 값을 입력받는다.
2. 입력받은 값을 range로해서 for문으로 반복
3. 1부터 값을 제곱 **2 시켜 빈 변수에 더하기 대입한다.
4. 나온 값을 return 시킨다.

#### 1-2 해당 프로그램의 복잡도는?

O(n) 이라고 생각된다.

#### 알려진 공식을 이용해 제작해보고 그 복잡도는?

```python
 def jegop2(self, n):
        return n * (n+1) * (2*n+1) // 6
```

1-1의 방법은 n이 커지면 n의 크기만큼 제곱하는 일과 더하기 대입하는 일이 늘어난다. 

하지만 공식을 이용해 알고리즘을 짜면 n 이 몇이 들어오든 주어진 공식만 수행하면 되므로 복잡도는 O(1)